module fpga_top (
    rst: input  'a reset_async_low,
    TCK: input  'a clock          ,
    TDO: output 'a logic          ,
    TDI: input  'a logic          ,
    TMS: input  'a logic          ,

    // interface
    led0: output 'b logic,
    led1: output 'b logic,
    led2: output 'b logic,
    led3: output 'b logic,
    btn0: input  'b logic,
    btn1: input  'b logic,
) {
    // instantiate the oscillator primitive in ../oscillator.sv
    var clk: 'b clock;
    inst osc: $sv::OSC_TOP (
        clk: clk,
    );
    var rst_b: 'b reset_async_low;
    // i think this is completely safe since the reset is async...
    unsafe (cdc) {
        assign rst_b = rst;
    }
    var prog_data: 'b logic<8>;
    var prog_rdy : 'b logic   ;
    inst prog: Programmer (
        rst_a : rst      ,
        TCK              ,
        TDO              ,
        TDI              ,
        TMS              ,
        clk_i : clk      ,
        rst_b            ,
        data_o: prog_data,
        rdy_o : prog_rdy ,
    );
    // some memory for testing
    var read    : 'b logic         ;
    var memory  : 'b logic<8>  [16];
    var idx     : 'b logic<5>      ;
    var pressed : 'b logic         ;
    var debounce: 'b logic<25>     ;

    always_ff (clk, rst_b) {
        if_reset {
            idx      = 0;
            debounce = 0;
            pressed  = 0;
            memory   = '{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
            read     = 0;
        } else {
            // debounce just counts cycles to debounce the buttons
            if debounce == 0 {
                // on btn0 / btn1 edge
                if (btn0 && !pressed) {
                    // increase / decrease the displayed memory index
                    idx     += 1;
                    pressed =  1;
                } else if btn1 && !pressed {
                    idx     -= 1;
                    pressed =  1;
                } else if !btn0 && !btn1 {
                    // if buttons are released, reset the edge tracker
                    pressed = 0;
                }
            } else {
                debounce += 1;
            }
            // if programmer has a byte for us and we haven't read it
            if prog_rdy && !read {
                // set the current memory byte to the received byte
                memory[idx] = prog_data;
                // but only once
                read = 1;
            } else if (!prog_rdy && read) {
                read = 0;
            }
        }
    }
    // idx >> 1 as 4 is the "byte pointer"
    // modulo points within the byte so byte[7:4] or byte[3:0]
    // we do this since we only have 4 leds.
    let modulo: 'b logic<4> = if (idx[0] == 1) ? 4 : 0;
    assign led0   = memory[(idx >> 1) as 4][(0 + modulo) as 3] as 1;
    assign led1   = memory[(idx >> 1) as 4][(1 + modulo) as 3] as 1;
    assign led2   = memory[(idx >> 1) as 4][(2 + modulo) as 3] as 1;
    assign led3   = memory[(idx >> 1) as 4][(3 + modulo) as 3] as 1;
}
